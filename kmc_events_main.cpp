#include <cstdio>
#include <iostream>
#include <vector>
#include <cmath>
#include "kmc_global.h"
#include "kmc_events.h"

using namespace std;

void class_events::events_main(){
	// a probability map will first generated by calculating all possible moves
	// then randomly picked the ACTUAL move based on the probability map
	
	vector <double> v_rate; v_rate.reserve(nV*8); // vacancy: rate(or probability)
	vector <int>    v_ivcc; v_ivcc.reserve(nV*8); // vacancy: id in the vacancy list 
	vector <int>    v_inbr; v_inbr.reserve(nV*8); // vacancy: id of the neighbor vector
	double vrate= vac_jump(v_rate, v_ivcc, v_inbr);

	double sum_rate= vrate; // sum_rate= v_rate + i_rate after we have interstitial jump events
	double ran= ran_generator();
	double acc_rate= 0; // accumulated rate

	for(int i=0; i<v_rate.size(); i ++){
		if( (ran > acc_rate) && (ran <= (acc_rate + v_rate.at(i)/sum_rate) ) ){
			int theV= v_ivcc.at(i);
			
			int vx= (int) (list_vcc.at(theV)/nz)/ny;
			int vy= (int) (list_vcc.at(theV)/nz)%ny;
			int vz= (int)  list_vcc.at(theV)%nz;
			
			int x= pbc(vx+(*(v1nbr+v_inbr.at(i)))[0], nx);
			int y= pbc(vy+(*(v1nbr+v_inbr.at(i)))[1], ny);
			int z= pbc(vz+(*(v1nbr+v_inbr.at(i)))[2], nz);

			*(states + vx*ny*nz + vy*nz + vz)= *(states + x*ny*nz + y*nz + z);
			*(states +  x*ny*nz +  y*nz +  z)= 0;

			list_vcc.at(theV)= x*ny*nz + y*nz + z;
			if((x-vx)>nx/2) ix.at(theV) --; if((x-vx)<-nx/2) ix.at(theV) ++; // ONE V
			if((y-vy)>ny/2) iy.at(theV) --; if((y-vy)<-ny/2) iy.at(theV) ++;
			if((z-vz)>nz/2) iz.at(theV) --; if((z-vz)<-nz/2) iz.at(theV) ++;

			if(*(states+vx*ny*nz+vy*nz+vz)==-1){
				actions_sol[0].push_back( x*ny*nz +  y*nz +  z);
				actions_sol[1].push_back(vx*ny*nz + vy*nz + vz);
			}
		}
		
		acc_rate += v_rate.at(i)/sum_rate;
	}
	
	if(abs(acc_rate-1.0)>0.00000001) error(2, "(vac_jump_void) acc_rate isnt 100p at the end", 1, acc_rate); // if dont need this, put acc_rate += ... into an else
	if(nA+nB+nV+nI != nx*ny*nz)  error(2, "(main) numbers of ltc points arent consistent", 2, nA+nB+nV+nI, nx*ny*nz); // check

	double dt= 1.0/sum_rate;
	timestep ++;
	totaltime += dt;
	if(timestep%step_write_his==0){
		write_hisvcc();
 		write_hissol(actions_sol);
	
		actions_sol[0].clear(); actions_sol[1].clear();
	}
}

// functions in backupfun:
//	int vpos[3];
//	events.vac_jump_random(par_pr_vjump, vpos);
//	events.vac_recb(vpos);
//	events.int_motions();

