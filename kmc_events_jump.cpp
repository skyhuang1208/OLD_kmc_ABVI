#include <cstdio>
#include <iostream>
#include <vector>
#include <cmath>
#include "kmc_global.h"
#include "kmc_events.h"

using namespace std;

double class_events::jump(){
	// a probability map will first generated by calculating all possible moves
	// then randomly picked the ACTUAL move based on the probability map

	// defect information: transition rates, positions, and directions
	vector <bool>   isvcc; // a vacancy of interstitial?
	vector <double> rates; // transition rates
	vector <int>    ilist; // IDs in the lists
	vector <int>    inbrs; // IDs of neighbor directions
	vector <int>	jatom; // the jumping atom
	double vrates= cal_ratesV(isvcc, rates, ilist, inbrs, jatom);
	double irates= cal_ratesI(isvcc, rates, ilist, inbrs, jatom);

	double sum_rates= vrates + irates; // sum of all rates
	double ran= ran_generator();
	double acc_rate= 0; // accumulated rate

	for(int i=0; i<rates.size(); i ++){
		if( (ran > acc_rate) && (ran <= (acc_rate + rates[i]/sum_rates) ) ){
			int did= ilist[i]; // defect ID
			int dx= (int) (list_vcc[did].ltcp/nz)/ny; // defect position
			int dy= (int) (list_vcc[did].ltcp/nz)%ny;
			int dz= (int)  list_vcc[did].ltcp%nz;
			
			int x= pbc(dx+v1nbr[inbrs[i]][0], nx); // neighbor position
			int y= pbc(dy+v1nbr[inbrs[i]][1], ny);
			int z= pbc(dz+v1nbr[inbrs[i]][2], nz);

			if(isvcc[i]){
				actual_jumpV(dx, dy, dz, x, y, z, did);
				recb_randomV(did);
			}
			else{
				if(inbrs[i]%4 != list_itl[did].dir%4) recb_randomI(did);
				actual_jumpI(dx, dy, dz, x, y, z, did, jatom[i], inbrs[i]);
				recb_dir(did);
			}
		}
		
		acc_rate += rates[i]/sum_rates;
	}
	
	if(abs(acc_rate-1.0)>0.00000001) error(2, "(jump) acc_rate isnt 100p at the end", 1, acc_rate); // check 
	if(nA+nB+nV+nAA+nBB+nAB != nx*ny*nz)  error(2, "(jump) numbers of ltc points arent consistent", 2, nA+nB+nV+nAA+nBB+nAB, nx*ny*nz); // check
	if(2*nAA+nA-nB-2*nBB != sum_mag)  error(2, "(jump) magnitization isnt conserved", 2, 2*nAA+nA-nB-2*nBB, sum_mag); // check

	double dt= 1.0/sum_rates;
	return dt;
}

void class_events::actual_jumpV(int dx, int dy, int dz, int x, int y, int z, int did){
	states[dx][dy][dz]= states[x][y][z];
	states[x][y][z]= 0;
	list_vcc[did].ltcp= x*ny*nz + y*nz + z;
				
	if((x-dx)>nx/2) list_vcc[did].ix --; if((x-dx)<-nx/2) list_vcc[did].ix ++;
	if((y-dy)>ny/2) list_vcc[did].iy --; if((y-dy)<-ny/2) list_vcc[did].iy ++;
	if((z-dz)>nz/2) list_vcc[did].iz --; if((z-dz)<-nz/2) list_vcc[did].iz ++;

	if(states[dx][dy][dz]==-1){
		actions_sol[0].push_back( x*ny*nz +  y*nz +  z);
		actions_sol[1].push_back(dx*ny*nz + dy*nz + dz);
	}
}

void class_events::actual_jumpI(int dx, int dy, int dz, int x, int y, int z, int did, int jatom, int inbr){
	switch(states[dx][dy][dz]){
		case  2: nAA --; break;
		case  0: nAB --; itlAB[dx][dy][dz]= false; break;
		case -2: nBB --; break;
		default: error(2, "(events_main) could not find the I type in --", 1, states[dx][dy][dz]);
	}
	switch(states[x][y][z]){
		case  1: nA --; 
			 break;
		case -1: nB --;
			 actions_sol[0].push_back(x*ny*nz + y*nz + z);
			 actions_sol[1].push_back(-2); // -2 meaning disapear
			 break;
		default: error(2, "(events_main) could not find the A type in --", 1, states[x][y][z]);
	}
	
	states[dx][dy][dz] -= jatom;
	states[x][y][z]    += jatom;
	
	switch(states[x][y][z]){
		case  2: nAA ++; break;
		case  0: nAB ++; itlAB[x][y][z]; break;
		case -2: nBB ++; break;
		default: error(2, "(events_main) could not find the I type in ++", 1, states[x][y][z]);
	}
	switch(states[dx][dy][dz]){
		case  1: nA ++; break;
		case -1: nB ++;
			 actions_sol[0].push_back(-1); // -1 meaning appear out of void
			 actions_sol[1].push_back(dx*ny*nz + dy*nz + dz);
			 break;
		default: error(2, "(events_main) could not find the A type in ++", 1, states[dx][dy][dz]);
	}
	
	list_itl[did].type= states[x][y][z];
	list_itl[did].ltcp= x*ny*nz + y*nz + z;
	list_itl[did].dir=  inbr;
	list_itl[did].head= states[x][y][z] - jatom;
	
	if((x-dx)>nx/2) list_itl[did].ix --; if((x-dx)<-nx/2) list_itl[did].ix ++;
	if((y-dy)>ny/2) list_itl[did].iy --; if((y-dy)<-ny/2) list_itl[did].iy ++;
	if((z-dz)>nz/2) list_itl[did].iz --; if((z-dz)<-nz/2) list_itl[did].iz ++;
}
	
// functions in backupfun:
//	int vpos[3];
//	events.vac_jump_random(par_pr_vjump, vpos);
//	events.vac_recb(vpos);
//	events.int_motions();

